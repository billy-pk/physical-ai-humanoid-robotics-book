"use strict";(globalThis.webpackChunkfrontend=globalThis.webpackChunkfrontend||[]).push([[7141],{8453:(n,e,i)=>{i.d(e,{R:()=>l,x:()=>r});var s=i(6540);const t={},o=s.createContext(t);function l(n){const e=s.useContext(o);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:l(n.components),s.createElement(o.Provider,{value:e},n.children)}},8992:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module-4/chapter-4-5","title":"4.5 Humanoid Kinematics & Balance Control","description":"Humanoid robots require sophisticated control algorithms to maintain balance while walking, manipulating objects, and navigating. This chapter covers forward/inverse kinematics, balance control (ZMP, LIPM), walking gaits, and integration with ROS 2 control stack.","source":"@site/docs/module-4/chapter-4-5.md","sourceDirName":"module-4","slug":"/module-4/chapter-4-5","permalink":"/physical-ai-humanoid-robotics-book/docs/module-4/chapter-4-5","draft":false,"unlisted":false,"editUrl":"https://github.com/billy-pk/physical-ai-humanoid-robotics-book/tree/main/frontend/docs/module-4/chapter-4-5.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6,"title":"4.5 Humanoid Kinematics & Balance Control"},"sidebar":"defaultSidebar","previous":{"title":"4.4 Multi-Modal Integration (Speech + Vision + Gesture)","permalink":"/physical-ai-humanoid-robotics-book/docs/module-4/chapter-4-4"},"next":{"title":"Capstone Project - Autonomous Humanoid System","permalink":"/physical-ai-humanoid-robotics-book/docs/module-4/capstone"}}');var t=i(4848),o=i(8453);const l={sidebar_position:6,title:"4.5 Humanoid Kinematics & Balance Control"},r="Chapter 4.5: Humanoid Kinematics & Balance Control",a={},c=[{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Part 1: Humanoid Kinematics Fundamentals",id:"part-1-humanoid-kinematics-fundamentals",level:2},{value:"Forward vs. Inverse Kinematics",id:"forward-vs-inverse-kinematics",level:3},{value:"Humanoid Structure",id:"humanoid-structure",level:3},{value:"Balance Control",id:"balance-control",level:3},{value:"Part 2: Hands-On Tutorial",id:"part-2-hands-on-tutorial",level:2},{value:"Project: Balance Control for Humanoid Robot",id:"project-balance-control-for-humanoid-robot",level:3},{value:"Step 1: Install Kinematics Libraries",id:"step-1-install-kinematics-libraries",level:3},{value:"Step 2: Forward Kinematics Implementation",id:"step-2-forward-kinematics-implementation",level:3},{value:"Step 3: Inverse Kinematics Implementation",id:"step-3-inverse-kinematics-implementation",level:3},{value:"Step 4: Balance Control (ZMP)",id:"step-4-balance-control-zmp",level:3},{value:"Step 5: Walking Gait Generator",id:"step-5-walking-gait-generator",level:3},{value:"Step 6: Integration with ROS 2 Control",id:"step-6-integration-with-ros-2-control",level:3},{value:"Step 7: Debugging Common Issues",id:"step-7-debugging-common-issues",level:3},{value:"Issue 1: &quot;IK solution not found&quot;",id:"issue-1-ik-solution-not-found",level:4},{value:"Issue 2: &quot;Robot falls over&quot; or &quot;Unstable balance&quot;",id:"issue-2-robot-falls-over-or-unstable-balance",level:4},{value:"Issue 3: &quot;Walking gait jerky&quot; or &quot;Unnatural motion&quot;",id:"issue-3-walking-gait-jerky-or-unnatural-motion",level:4},{value:"Part 3: Advanced Topics (Optional)",id:"part-3-advanced-topics-optional",level:2},{value:"Model Predictive Control (MPC)",id:"model-predictive-control-mpc",level:3},{value:"Whole-Body Control",id:"whole-body-control",level:3},{value:"Integration with Capstone",id:"integration-with-capstone",level:2},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Exercise 1: Forward Kinematics (Required)",id:"exercise-1-forward-kinematics-required",level:3},{value:"Exercise 2: Inverse Kinematics (Required)",id:"exercise-2-inverse-kinematics-required",level:3},{value:"Exercise 3: Balance Control (Challenge)",id:"exercise-3-balance-control-challenge",level:3},{value:"Additional Resources",id:"additional-resources",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"chapter-45-humanoid-kinematics--balance-control",children:"Chapter 4.5: Humanoid Kinematics & Balance Control"})}),"\n",(0,t.jsx)(e.p,{children:"Humanoid robots require sophisticated control algorithms to maintain balance while walking, manipulating objects, and navigating. This chapter covers forward/inverse kinematics, balance control (ZMP, LIPM), walking gaits, and integration with ROS 2 control stack."}),"\n",(0,t.jsx)(e.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,t.jsx)(e.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Understand"})," forward and inverse kinematics for humanoid robots"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Implement"})," balance control algorithms (ZMP, Linear Inverted Pendulum Model)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Configure"})," walking gaits and manipulation poses"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Integrate"})," kinematics and balance with ROS 2 control stack"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Debug"})," balance and walking issues"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"ROS 2 Humble"})," configured (Module 1)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"URDF modeling"})," experience (Module 1, Chapter 1.3)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Basic robotics"})," concepts: coordinate frames, transformations, Jacobians"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Mathematics"}),": Linear algebra, trigonometry, calculus basics"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Python 3.10+"})," with numpy, scipy"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"part-1-humanoid-kinematics-fundamentals",children:"Part 1: Humanoid Kinematics Fundamentals"}),"\n",(0,t.jsx)(e.h3,{id:"forward-vs-inverse-kinematics",children:"Forward vs. Inverse Kinematics"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Forward Kinematics (FK)"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Input"}),": Joint angles (\u03b8\u2081, \u03b8\u2082, ..., \u03b8\u2099)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Output"}),": End-effector pose (position + orientation)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Question"}),': "Where is the hand given joint angles?"']}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Inverse Kinematics (IK)"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Input"}),": Desired end-effector pose"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Output"}),": Joint angles to achieve pose"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Question"}),': "What joint angles put the hand here?"']}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"For humanoids"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Walking"}),": IK for foot placement, FK for center of mass"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Manipulation"}),": IK for hand positioning, FK for reachability"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Balance"}),": FK for center of mass calculation"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"humanoid-structure",children:"Humanoid Structure"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Typical humanoid"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Torso"}),": Base link (6 DOF: x, y, z, roll, pitch, yaw)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Legs"}),": 6 DOF each (hip 3 + knee 1 + ankle 2)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Arms"}),": 7 DOF each (shoulder 3 + elbow 1 + wrist 3)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Head"}),": 2 DOF (pan + tilt)"]}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Total"}),": ~30+ degrees of freedom"]}),"\n",(0,t.jsx)(e.h3,{id:"balance-control",children:"Balance Control"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Why balance matters"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Stability"}),": Prevent falling"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Walking"}),": Maintain balance while moving"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Manipulation"}),": Don't tip over when reaching"]}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Balance methods"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"ZMP (Zero Moment Point)"}),": Point where net moment is zero"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"LIPM (Linear Inverted Pendulum Model)"}),": Simplified dynamics model"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"MPC (Model Predictive Control)"}),": Optimal control with preview"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"part-2-hands-on-tutorial",children:"Part 2: Hands-On Tutorial"}),"\n",(0,t.jsx)(e.h3,{id:"project-balance-control-for-humanoid-robot",children:"Project: Balance Control for Humanoid Robot"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Goal"}),": Implement basic balance control and walking gait for humanoid robot."]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Tools"}),": ROS 2 Humble, Python 3.10+, numpy, scipy, PyKDL (kinematics library)"]}),"\n",(0,t.jsx)(e.h3,{id:"step-1-install-kinematics-libraries",children:"Step 1: Install Kinematics Libraries"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Install PyKDL"})," (ROS kinematics library):"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"sudo apt install ros-humble-kdl-parser-py ros-humble-orocos-kdl\npip3 install PyKDL\n"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Install scipy"})," (for optimization):"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"pip3 install scipy\n"})}),"\n",(0,t.jsx)(e.h3,{id:"step-2-forward-kinematics-implementation",children:"Step 2: Forward Kinematics Implementation"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Create FK node"}),": ",(0,t.jsx)(e.code,{children:"voice_commands/kinematics_node.py"})]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\nForward and inverse kinematics for humanoid robot\nROS 2 Humble | Python 3.10+ | PyKDL\n"""\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom geometry_msgs.msg import PoseStamped, Point, Quaternion\nimport numpy as np\nfrom scipy.spatial.transform import Rotation\n\nclass KinematicsNode(Node):\n    """\n    Calculates forward and inverse kinematics for humanoid\n    """\n    def __init__(self):\n        super().__init__(\'kinematics_node\')\n        \n        # Subscribe to joint states\n        self.joint_sub = self.create_subscription(\n            JointState,\n            \'/joint_states\',\n            self.joint_callback,\n            10\n        )\n        \n        # Publisher for end-effector poses\n        self.left_hand_pub = self.create_publisher(PoseStamped, \'/kinematics/left_hand_pose\', 10)\n        self.right_hand_pub = self.create_publisher(PoseStamped, \'/kinematics/right_hand_pose\', 10)\n        self.left_foot_pub = self.create_publisher(PoseStamped, \'/kinematics/left_foot_pose\', 10)\n        self.right_foot_pub = self.create_publisher(PoseStamped, \'/kinematics/right_foot_pose\', 10)\n        self.com_pub = self.create_publisher(Point, \'/kinematics/center_of_mass\', 10)\n        \n        # Robot parameters (from URDF)\n        self.link_lengths = {\n            \'torso_height\': 0.4,\n            \'thigh_length\': 0.3,\n            \'shank_length\': 0.3,\n            \'foot_length\': 0.15,\n            \'upper_arm_length\': 0.25,\n            \'forearm_length\': 0.25,\n        }\n        \n        self.get_logger().info(\'Kinematics node started\')\n    \n    def joint_callback(self, msg):\n        """Calculate FK from joint states"""\n        # Extract joint angles\n        joint_angles = {}\n        for i, name in enumerate(msg.name):\n            joint_angles[name] = msg.position[i]\n        \n        # Calculate end-effector poses\n        left_foot_pose = self.calculate_left_foot_pose(joint_angles)\n        right_foot_pose = self.calculate_right_foot_pose(joint_angles)\n        left_hand_pose = self.calculate_left_hand_pose(joint_angles)\n        right_hand_pose = self.calculate_right_hand_pose(joint_angles)\n        com_position = self.calculate_center_of_mass(joint_angles)\n        \n        # Publish poses\n        self.publish_pose(self.left_foot_pub, left_foot_pose, \'base_link\')\n        self.publish_pose(self.right_foot_pub, right_foot_pose, \'base_link\')\n        self.publish_pose(self.left_hand_pub, left_hand_pose, \'base_link\')\n        self.publish_pose(self.right_hand_pub, right_hand_pose, \'base_link\')\n        \n        # Publish center of mass\n        com_msg = Point()\n        com_msg.x = com_position[0]\n        com_msg.y = com_position[1]\n        com_msg.z = com_position[2]\n        self.com_pub.publish(com_msg)\n    \n    def calculate_left_foot_pose(self, joint_angles):\n        """Calculate left foot pose using FK"""\n        # Simplified FK for leg (would use proper DH parameters in production)\n        hip_yaw = joint_angles.get(\'left_hip_yaw\', 0.0)\n        hip_pitch = joint_angles.get(\'left_hip_pitch\', 0.0)\n        hip_roll = joint_angles.get(\'left_hip_roll\', 0.0)\n        knee = joint_angles.get(\'left_knee\', 0.0)\n        ankle_pitch = joint_angles.get(\'left_ankle_pitch\', 0.0)\n        ankle_roll = joint_angles.get(\'left_ankle_roll\', 0.0)\n        \n        # Forward kinematics (simplified)\n        # Position relative to hip\n        thigh_len = self.link_lengths[\'thigh_length\']\n        shank_len = self.link_lengths[\'shank_length\']\n        \n        # Calculate foot position (simplified 2D in sagittal plane)\n        x = thigh_len * np.sin(hip_pitch) + shank_len * np.sin(hip_pitch + knee)\n        z = -thigh_len * np.cos(hip_pitch) - shank_len * np.cos(hip_pitch + knee)\n        y = 0.1  # Left leg offset\n        \n        # Apply hip yaw and roll\n        # ... (full 3D transformation)\n        \n        return np.array([x, y, z])\n    \n    def calculate_right_foot_pose(self, joint_angles):\n        """Calculate right foot pose (similar to left)"""\n        # Similar to left foot, with y = -0.1\n        return np.array([0.0, -0.1, -0.6])  # Placeholder\n    \n    def calculate_left_hand_pose(self, joint_angles):\n        """Calculate left hand pose"""\n        # Similar FK for arm\n        return np.array([0.0, 0.2, 0.8])  # Placeholder\n    \n    def calculate_right_hand_pose(self, joint_angles):\n        """Calculate right hand pose"""\n        return np.array([0.0, -0.2, 0.8])  # Placeholder\n    \n    def calculate_center_of_mass(self, joint_angles):\n        """Calculate center of mass position"""\n        # Weighted average of link centers\n        # Simplified: Assume CoM at torso center\n        return np.array([0.0, 0.0, 0.5])  # Placeholder\n    \n    def publish_pose(self, publisher, position, frame_id):\n        """Publish pose message"""\n        pose = PoseStamped()\n        pose.header.frame_id = frame_id\n        pose.header.stamp = self.get_clock().now().to_msg()\n        pose.pose.position.x = position[0]\n        pose.pose.position.y = position[1]\n        pose.pose.position.z = position[2]\n        pose.pose.orientation.w = 1.0  # Default orientation\n        publisher.publish(pose)\n'})}),"\n",(0,t.jsx)(e.h3,{id:"step-3-inverse-kinematics-implementation",children:"Step 3: Inverse Kinematics Implementation"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Create IK solver"}),": ",(0,t.jsx)(e.code,{children:"voice_commands/ik_solver.py"})]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\nInverse kinematics solver for humanoid\nROS 2 Humble | Python 3.10+ | scipy\n"""\nimport numpy as np\nfrom scipy.optimize import minimize\n\nclass IKSolver:\n    """\n    Solves inverse kinematics for humanoid limbs\n    """\n    def __init__(self, link_lengths):\n        self.link_lengths = link_lengths\n    \n    def solve_leg_ik(self, target_foot_pose, initial_angles=None):\n        """\n        Solve IK for leg to achieve target foot pose\n        Returns joint angles: [hip_yaw, hip_pitch, hip_roll, knee, ankle_pitch, ankle_roll]\n        """\n        if initial_angles is None:\n            initial_angles = np.zeros(6)\n        \n        def objective(joint_angles):\n            """Minimize distance between current and target pose"""\n            current_pose = self.forward_kinematics_leg(joint_angles)\n            error = np.linalg.norm(current_pose - target_foot_pose)\n            return error\n        \n        # Joint limits\n        bounds = [\n            (-1.57, 1.57),   # hip_yaw\n            (-1.57, 1.57),   # hip_pitch\n            (-0.5, 0.5),     # hip_roll\n            (0, 3.14),       # knee\n            (-0.5, 0.5),     # ankle_pitch\n            (-0.5, 0.5),     # ankle_roll\n        ]\n        \n        result = minimize(objective, initial_angles, bounds=bounds, method=\'L-BFGS-B\')\n        \n        if result.success:\n            return result.x\n        else:\n            return None\n    \n    def forward_kinematics_leg(self, joint_angles):\n        """Calculate foot pose from joint angles (simplified)"""\n        hip_pitch = joint_angles[1]\n        knee = joint_angles[3]\n        \n        thigh_len = self.link_lengths[\'thigh_length\']\n        shank_len = self.link_lengths[\'shank_length\']\n        \n        x = thigh_len * np.sin(hip_pitch) + shank_len * np.sin(hip_pitch + knee)\n        z = -thigh_len * np.cos(hip_pitch) - shank_len * np.cos(hip_pitch + knee)\n        \n        return np.array([x, 0, z])\n'})}),"\n",(0,t.jsx)(e.h3,{id:"step-4-balance-control-zmp",children:"Step 4: Balance Control (ZMP)"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Create balance controller"}),": ",(0,t.jsx)(e.code,{children:"voice_commands/balance_controller.py"})]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\nBalance control using ZMP (Zero Moment Point)\nROS 2 Humble | Python 3.10+\n"""\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Point\nfrom std_msgs.msg import Float64MultiArray\nimport numpy as np\n\nclass BalanceController(Node):\n    """\n    Maintains humanoid balance using ZMP control\n    """\n    def __init__(self):\n        super().__init__(\'balance_controller\')\n        \n        # Subscribe to center of mass\n        self.com_sub = self.create_subscription(\n            Point,\n            \'/kinematics/center_of_mass\',\n            self.com_callback,\n            10\n        )\n        \n        # Subscribe to foot contact forces (would come from sensors)\n        # For now: Assume both feet on ground\n        \n        # Publisher for balance corrections\n        self.balance_cmd_pub = self.create_publisher(\n            Float64MultiArray,\n            \'/balance/commands\',\n            10\n        )\n        \n        # ZMP parameters\n        self.support_polygon = np.array([\n            [-0.1, -0.05],  # Left foot corners\n            [0.1, -0.05],\n            [0.1, 0.05],\n            [-0.1, 0.05]\n        ])\n        \n        self.desired_zmp = np.array([0.0, 0.0])  # Center of support polygon\n        \n        self.get_logger().info(\'Balance controller started\')\n    \n    def com_callback(self, msg):\n        """Calculate ZMP and generate balance corrections"""\n        com_position = np.array([msg.x, msg.y, msg.z])\n        \n        # Calculate current ZMP (simplified: assume CoM projects to ground)\n        current_zmp = np.array([com_position[0], com_position[1]])\n        \n        # Calculate ZMP error\n        zmp_error = current_zmp - self.desired_zmp\n        \n        # Generate balance correction (adjust joint angles to shift CoM)\n        correction = self.calculate_balance_correction(zmp_error)\n        \n        # Publish correction commands\n        cmd_msg = Float64MultiArray()\n        cmd_msg.data = correction.tolist()\n        self.balance_cmd_pub.publish(cmd_msg)\n    \n    def calculate_balance_correction(self, zmp_error):\n        """Calculate joint angle corrections to maintain balance"""\n        # Simplified: Adjust ankle angles to shift CoM\n        # In production: Use full-body IK or MPC\n        \n        max_correction = 0.1  # Radians\n        \n        # Proportional control\n        kp = 0.5\n        correction_x = -kp * zmp_error[0]  # Negative for stability\n        correction_y = -kp * zmp_error[1]\n        \n        # Limit corrections\n        correction_x = np.clip(correction_x, -max_correction, max_correction)\n        correction_y = np.clip(correction_y, -max_correction, max_correction)\n        \n        # Return corrections for ankle joints\n        return np.array([\n            correction_x,  # Left ankle pitch\n            correction_y,  # Left ankle roll\n            correction_x,  # Right ankle pitch\n            correction_y,  # Right ankle roll\n        ])\n    \n    def is_zmp_in_support_polygon(self, zmp):\n        """Check if ZMP is within support polygon"""\n        # Simplified point-in-polygon check\n        # In production: Use proper polygon containment algorithm\n        return True  # Placeholder\n'})}),"\n",(0,t.jsx)(e.h3,{id:"step-5-walking-gait-generator",children:"Step 5: Walking Gait Generator"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Create gait generator"}),": ",(0,t.jsx)(e.code,{children:"voice_commands/gait_generator.py"})]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\nWalking gait generator for humanoid\nROS 2 Humble | Python 3.10+\n"""\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import Float64MultiArray\nimport numpy as np\n\nclass GaitGenerator(Node):\n    """\n    Generates walking gait patterns for humanoid\n    """\n    def __init__(self):\n        super().__init__(\'gait_generator\')\n        \n        # Gait parameters\n        self.step_length = 0.2  # meters\n        self.step_height = 0.05  # meters\n        self.step_duration = 1.0  # seconds\n        self.stance_phase_ratio = 0.6  # 60% stance, 40% swing\n        \n        # State\n        self.phase = 0.0  # 0 to 1 (gait cycle)\n        self.left_foot_swing = False\n        self.right_foot_swing = False\n        \n        # Publisher for joint commands\n        self.joint_cmd_pub = self.create_publisher(\n            Float64MultiArray,\n            \'/gait/joint_commands\',\n            10\n        )\n        \n        # Timer for gait cycle\n        self.gait_timer = self.create_timer(0.01, self.update_gait)  # 100 Hz\n        \n        self.get_logger().info(\'Gait generator started\')\n    \n    def update_gait(self):\n        """Update gait cycle and generate joint commands"""\n        # Update phase\n        dt = 0.01  # Timer period\n        phase_increment = dt / self.step_duration\n        self.phase += phase_increment\n        \n        if self.phase >= 1.0:\n            self.phase = 0.0\n            # Switch swing leg\n            self.left_foot_swing = not self.left_foot_swing\n            self.right_foot_swing = not self.right_foot_swing\n        \n        # Generate joint angles for current phase\n        joint_angles = self.generate_gait_angles()\n        \n        # Publish joint commands\n        cmd_msg = Float64MultiArray()\n        cmd_msg.data = joint_angles.tolist()\n        self.joint_cmd_pub.publish(cmd_msg)\n    \n    def generate_gait_angles(self):\n        """Generate joint angles for current gait phase"""\n        # Simplified gait: sinusoidal trajectories\n        # In production: Use optimized trajectories\n        \n        # Base angles (standing pose)\n        left_hip_pitch = 0.0\n        left_knee = 0.0\n        left_ankle_pitch = 0.0\n        \n        right_hip_pitch = 0.0\n        right_knee = 0.0\n        right_ankle_pitch = 0.0\n        \n        # Add gait motion\n        if self.left_foot_swing:\n            # Left foot swinging\n            swing_phase = self.phase / self.stance_phase_ratio if self.phase < self.stance_phase_ratio else (self.phase - self.stance_phase_ratio) / (1 - self.stance_phase_ratio)\n            \n            left_hip_pitch = np.sin(swing_phase * np.pi) * 0.3  # Lift leg\n            left_knee = np.sin(swing_phase * np.pi) * 0.5  # Bend knee\n            left_ankle_pitch = -np.sin(swing_phase * np.pi) * 0.2  # Point toe\n        \n        if self.right_foot_swing:\n            # Right foot swinging (similar)\n            swing_phase = self.phase / self.stance_phase_ratio if self.phase < self.stance_phase_ratio else (self.phase - self.stance_phase_ratio) / (1 - self.stance_phase_ratio)\n            \n            right_hip_pitch = np.sin(swing_phase * np.pi) * 0.3\n            right_knee = np.sin(swing_phase * np.pi) * 0.5\n            right_ankle_pitch = -np.sin(swing_phase * np.pi) * 0.2\n        \n        # Return all joint angles\n        return np.array([\n            left_hip_pitch, left_knee, left_ankle_pitch,\n            right_hip_pitch, right_knee, right_ankle_pitch,\n            # ... (add other joints)\n        ])\n    \n    def start_walking(self, direction=\'forward\', speed=0.5):\n        """Start walking in specified direction"""\n        self.walking = True\n        self.direction = direction\n        self.speed = speed\n        self.get_logger().info(f\'Starting to walk {direction} at speed {speed}\')\n    \n    def stop_walking(self):\n        """Stop walking and return to standing pose"""\n        self.walking = False\n        self.get_logger().info(\'Stopping walk\')\n'})}),"\n",(0,t.jsx)(e.h3,{id:"step-6-integration-with-ros-2-control",children:"Step 6: Integration with ROS 2 Control"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Create control interface"}),": ",(0,t.jsx)(e.code,{children:"voice_commands/control_interface.py"})]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\nControl interface for humanoid robot\nIntegrates kinematics, balance, and gait\nROS 2 Humble | Python 3.10+\n"""\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import Float64MultiArray\nfrom geometry_msgs.msg import PoseStamped\n\nclass ControlInterface(Node):\n    """\n    Unified control interface for humanoid\n    """\n    def __init__(self):\n        super().__init__(\'control_interface\')\n        \n        # Subscribe to action goals\n        self.action_goal_sub = self.create_subscription(\n            PoseStamped,\n            \'/control/goal_pose\',\n            self.goal_callback,\n            10\n        )\n        \n        # Publishers\n        self.joint_cmd_pub = self.create_publisher(\n            Float64MultiArray,\n            \'/joint_commands\',\n            10\n        )\n        \n        # Internal components (would instantiate actual classes)\n        # self.ik_solver = IKSolver(...)\n        # self.balance_controller = BalanceController(...)\n        # self.gait_generator = GaitGenerator(...)\n        \n        self.get_logger().info(\'Control interface started\')\n    \n    def goal_callback(self, msg):\n        """Handle control goal (e.g., move hand to pose)"""\n        target_pose = msg.pose\n        \n        # Solve IK to achieve pose\n        # joint_angles = self.ik_solver.solve_arm_ik(target_pose)\n        \n        # Apply balance corrections\n        # balance_correction = self.balance_controller.get_correction()\n        \n        # Combine and publish joint commands\n        # final_angles = joint_angles + balance_correction\n        # self.publish_joint_commands(final_angles)\n        \n        self.get_logger().info(\'Control goal received\')\n    \n    def publish_joint_commands(self, joint_angles):\n        """Publish joint angle commands"""\n        msg = Float64MultiArray()\n        msg.data = joint_angles.tolist()\n        self.joint_cmd_pub.publish(msg)\n'})}),"\n",(0,t.jsx)(e.h3,{id:"step-7-debugging-common-issues",children:"Step 7: Debugging Common Issues"}),"\n",(0,t.jsx)(e.h4,{id:"issue-1-ik-solution-not-found",children:'Issue 1: "IK solution not found"'}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Symptoms"}),": IK solver fails to find solution"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Solutions"}),":"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"# Check if target is within workspace\n# Increase joint limits if needed\n# Use better initial guess\n# Try multiple IK solvers (analytical vs. numerical)\n"})}),"\n",(0,t.jsx)(e.h4,{id:"issue-2-robot-falls-over-or-unstable-balance",children:'Issue 2: "Robot falls over" or "Unstable balance"'}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Symptoms"}),": Robot tips over during motion"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Solutions"}),":"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"# Increase support polygon (wider stance)\n# Improve ZMP control gains\n# Add damping to balance controller\n# Slow down motion (reduce speed)\n"})}),"\n",(0,t.jsx)(e.h4,{id:"issue-3-walking-gait-jerky-or-unnatural-motion",children:'Issue 3: "Walking gait jerky" or "Unnatural motion"'}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Symptoms"}),": Robot movement is not smooth"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Solutions"}),":"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"# Smooth joint trajectories (use splines)\n# Optimize gait parameters (step length, duration)\n# Add acceleration limits\n# Use motion planning (trajectory optimization)\n"})}),"\n",(0,t.jsx)(e.h2,{id:"part-3-advanced-topics-optional",children:"Part 3: Advanced Topics (Optional)"}),"\n",(0,t.jsx)(e.h3,{id:"model-predictive-control-mpc",children:"Model Predictive Control (MPC)"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Advanced balance control"}),":"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"# Use MPC for optimal balance control\n# Preview future ZMP trajectory\n# Optimize joint trajectories\n# Handle constraints (joint limits, torque limits)\n"})}),"\n",(0,t.jsx)(e.h3,{id:"whole-body-control",children:"Whole-Body Control"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Coordinate all joints"}),":"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"# Solve IK for entire body simultaneously\n# Consider balance constraints\n# Optimize for energy efficiency\n# Handle redundancy (multiple solutions)\n"})}),"\n",(0,t.jsx)(e.h2,{id:"integration-with-capstone",children:"Integration with Capstone"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"How this chapter contributes"})," to the Week 13 autonomous humanoid:"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Manipulation"}),": IK enables precise hand positioning for grasping"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Navigation"}),": Walking gaits enable locomotion"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Balance"}),": Balance control prevents falls during actions"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Integration"}),": Connects high-level actions to low-level control"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"Understanding kinematics and balance now is essential for the capstone robot control."}),"\n",(0,t.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(e.p,{children:"You learned:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\u2705 Understood ",(0,t.jsx)(e.strong,{children:"forward and inverse kinematics"})," for humanoid robots"]}),"\n",(0,t.jsxs)(e.li,{children:["\u2705 Implemented ",(0,t.jsx)(e.strong,{children:"balance control algorithms"})," (ZMP) for stability"]}),"\n",(0,t.jsxs)(e.li,{children:["\u2705 Configured ",(0,t.jsx)(e.strong,{children:"walking gaits"})," for locomotion"]}),"\n",(0,t.jsxs)(e.li,{children:["\u2705 Integrated ",(0,t.jsx)(e.strong,{children:"kinematics and balance"})," with ROS 2 control"]}),"\n",(0,t.jsxs)(e.li,{children:["\u2705 Debugged ",(0,t.jsx)(e.strong,{children:"balance and walking issues"})]}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Next steps"}),": Complete the capstone project integrating all modules into a complete autonomous humanoid system."]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,t.jsx)(e.h3,{id:"exercise-1-forward-kinematics-required",children:"Exercise 1: Forward Kinematics (Required)"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Objective"}),": Calculate end-effector poses from joint angles."]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Tasks"}),":"]}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Implement FK for one leg"}),"\n",(0,t.jsx)(e.li,{children:"Test with known joint angles"}),"\n",(0,t.jsx)(e.li,{children:"Verify foot pose matches expected position"}),"\n",(0,t.jsx)(e.li,{children:"Extend to arm FK"}),"\n",(0,t.jsx)(e.li,{children:"Visualize poses in RViz2"}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Acceptance Criteria"}),":"]}),"\n",(0,t.jsxs)(e.ul,{className:"contains-task-list",children:["\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","FK implemented for leg"]}),"\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Calculated poses match expected values"]}),"\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Poses visualized in RViz2"]}),"\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","FK extended to arm"]}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Estimated Time"}),": 120 minutes"]}),"\n",(0,t.jsx)(e.h3,{id:"exercise-2-inverse-kinematics-required",children:"Exercise 2: Inverse Kinematics (Required)"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Objective"}),": Solve IK to achieve target end-effector poses."]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Tasks"}),":"]}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Implement IK solver for leg"}),"\n",(0,t.jsx)(e.li,{children:"Test with target foot poses"}),"\n",(0,t.jsx)(e.li,{children:"Verify solution achieves target"}),"\n",(0,t.jsx)(e.li,{children:"Handle joint limits"}),"\n",(0,t.jsx)(e.li,{children:"Test with unreachable targets (should fail gracefully)"}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Acceptance Criteria"}),":"]}),"\n",(0,t.jsxs)(e.ul,{className:"contains-task-list",children:["\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","IK solver implemented"]}),"\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Solutions achieve target poses"]}),"\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Joint limits respected"]}),"\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Unreachable targets handled"]}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Estimated Time"}),": 180 minutes"]}),"\n",(0,t.jsx)(e.h3,{id:"exercise-3-balance-control-challenge",children:"Exercise 3: Balance Control (Challenge)"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Objective"}),": Implement ZMP-based balance control."]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Tasks"}),":"]}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Calculate ZMP from center of mass"}),"\n",(0,t.jsx)(e.li,{children:"Implement ZMP controller"}),"\n",(0,t.jsx)(e.li,{children:"Test balance corrections"}),"\n",(0,t.jsx)(e.li,{children:"Integrate with walking gait"}),"\n",(0,t.jsx)(e.li,{children:"Validate balance during walking"}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Requirements"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"ZMP calculation"}),"\n",(0,t.jsx)(e.li,{children:"Balance controller"}),"\n",(0,t.jsx)(e.li,{children:"Integration with gait"}),"\n",(0,t.jsx)(e.li,{children:"Balance validation"}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Estimated Time"}),": 240 minutes"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"additional-resources",children:"Additional Resources"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.a,{href:"https://www.springer.com/series/15556",children:"Humanoid Robotics"})," - Textbook on humanoid control"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.a,{href:"https://ieeexplore.ieee.org/document/1232809",children:"ZMP Control"})," - Research paper"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.a,{href:"https://www.orocos.org/kdl.html",children:"PyKDL Documentation"})," - Kinematics library"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.a,{href:"https://control.ros.org/",children:"ROS 2 Control"})," - ROS 2 control framework"]}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Next"}),": ",(0,t.jsx)(e.a,{href:"/physical-ai-humanoid-robotics-book/docs/module-4/capstone",children:"Capstone Project: Autonomous Humanoid System \u2192"})]})]})}function h(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}}}]);