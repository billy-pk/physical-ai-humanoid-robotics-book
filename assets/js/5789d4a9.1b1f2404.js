"use strict";(globalThis.webpackChunkfrontend=globalThis.webpackChunkfrontend||[]).push([[9224],{8453:(n,e,i)=>{i.d(e,{R:()=>t,x:()=>o});var s=i(6540);const r={},l=s.createContext(r);function t(n){const e=s.useContext(l);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:t(n.components),s.createElement(l.Provider,{value:e},n.children)}},9040:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"module-2/chapter-2-2","title":"2.2 Physics Simulation (Gravity, Collisions, Friction)","description":"Realistic physics simulation is critical for humanoid robots. Walking, balancing, and manipulation all depend on accurate modeling of gravity, collisions, and friction. This chapter covers configuring Gazebo\'s physics engines to simulate realistic humanoid dynamics.","source":"@site/docs/module-2/chapter-2-2.md","sourceDirName":"module-2","slug":"/module-2/chapter-2-2","permalink":"/physical-ai-humanoid-robotics-book/docs/module-2/chapter-2-2","draft":false,"unlisted":false,"editUrl":"https://github.com/billy-pk/physical-ai-humanoid-robotics-book/tree/main/frontend/docs/module-2/chapter-2-2.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"2.2 Physics Simulation (Gravity, Collisions, Friction)"},"sidebar":"defaultSidebar","previous":{"title":"2.1 Gazebo Fundamentals & Setup","permalink":"/physical-ai-humanoid-robotics-book/docs/module-2/chapter-2-1"},"next":{"title":"2.3 Sensor Simulation (LiDAR, Cameras, IMUs)","permalink":"/physical-ai-humanoid-robotics-book/docs/module-2/chapter-2-3"}}');var r=i(4848),l=i(8453);const t={sidebar_position:3,title:"2.2 Physics Simulation (Gravity, Collisions, Friction)"},o="Chapter 2.2: Physics Simulation (Gravity, Collisions, Friction)",c={},a=[{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Part 1: Physics Engine Fundamentals",id:"part-1-physics-engine-fundamentals",level:2},{value:"Physics Engines in Gazebo",id:"physics-engines-in-gazebo",level:3},{value:"Key Physics Parameters",id:"key-physics-parameters",level:3},{value:"1. Gravity",id:"1-gravity",level:4},{value:"2. Collision Detection",id:"2-collision-detection",level:4},{value:"3. Friction",id:"3-friction",level:4},{value:"4. Inertia",id:"4-inertia",level:4},{value:"Solver Parameters",id:"solver-parameters",level:3},{value:"Part 2: Hands-On Tutorial",id:"part-2-hands-on-tutorial",level:2},{value:"Project: Simulate Humanoid Walking Dynamics",id:"project-simulate-humanoid-walking-dynamics",level:3},{value:"Step 1: Create Simple Humanoid URDF",id:"step-1-create-simple-humanoid-urdf",level:3},{value:"Step 2: Create Gazebo World with Physics",id:"step-2-create-gazebo-world-with-physics",level:3},{value:"Step 3: Launch Humanoid in Gazebo",id:"step-3-launch-humanoid-in-gazebo",level:3},{value:"Step 4: Test Physics Parameters",id:"step-4-test-physics-parameters",level:3},{value:"Step 5: Debugging Physics Issues",id:"step-5-debugging-physics-issues",level:3},{value:"Issue 1: Objects Penetrating Ground",id:"issue-1-objects-penetrating-ground",level:4},{value:"Issue 2: Jittering/Shaking",id:"issue-2-jitteringshaking",level:4},{value:"Issue 3: Unrealistic Bouncing",id:"issue-3-unrealistic-bouncing",level:4},{value:"Part 3: Advanced Topics (Optional)",id:"part-3-advanced-topics-optional",level:2},{value:"Bullet Physics Engine",id:"bullet-physics-engine",level:3},{value:"Contact Forces Visualization",id:"contact-forces-visualization",level:3},{value:"Integration with Capstone",id:"integration-with-capstone",level:2},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Exercise 1: Friction Experiment (Required)",id:"exercise-1-friction-experiment-required",level:3},{value:"Exercise 2: Inertia Tuning (Required)",id:"exercise-2-inertia-tuning-required",level:3},{value:"Exercise 3: Physics Solver Tuning (Challenge)",id:"exercise-3-physics-solver-tuning-challenge",level:3},{value:"Additional Resources",id:"additional-resources",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"chapter-22-physics-simulation-gravity-collisions-friction",children:"Chapter 2.2: Physics Simulation (Gravity, Collisions, Friction)"})}),"\n",(0,r.jsx)(e.p,{children:"Realistic physics simulation is critical for humanoid robots. Walking, balancing, and manipulation all depend on accurate modeling of gravity, collisions, and friction. This chapter covers configuring Gazebo's physics engines to simulate realistic humanoid dynamics."}),"\n",(0,r.jsx)(e.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,r.jsx)(e.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Configure"})," physics engines (ODE, Bullet) for humanoid dynamics"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Model"})," gravity, friction coefficients, and collision properties"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Simulate"})," humanoid walking and balance dynamics"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Debug"})," physics artifacts (penetration, jitter, instability)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Tune"})," solver parameters for stability vs. performance tradeoffs"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Gazebo Classic 11"})," installed (Chapter 2.1)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"ROS 2 Humble"})," configured"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Basic understanding"})," of physics (forces, torques, Newton's laws)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"URDF modeling"})," experience (from Module 1)"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"part-1-physics-engine-fundamentals",children:"Part 1: Physics Engine Fundamentals"}),"\n",(0,r.jsx)(e.h3,{id:"physics-engines-in-gazebo",children:"Physics Engines in Gazebo"}),"\n",(0,r.jsx)(e.p,{children:"Gazebo supports multiple physics engines:"}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Engine"}),(0,r.jsx)(e.th,{children:"Strengths"}),(0,r.jsx)(e.th,{children:"Use Cases"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsxs)(e.td,{children:[(0,r.jsx)(e.strong,{children:"ODE"})," (Open Dynamics Engine)"]}),(0,r.jsx)(e.td,{children:"Fast, stable, default"}),(0,r.jsx)(e.td,{children:"General robotics, humanoids"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Bullet"})}),(0,r.jsx)(e.td,{children:"Accurate collisions, soft bodies"}),(0,r.jsx)(e.td,{children:"Manipulation, grasping"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"DART"})}),(0,r.jsx)(e.td,{children:"Advanced constraints"}),(0,r.jsx)(e.td,{children:"Complex mechanisms"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Simbody"})}),(0,r.jsx)(e.td,{children:"Biomechanics"}),(0,r.jsx)(e.td,{children:"Human motion simulation"})]})]})]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"This course uses ODE"})," (default, most widely used)."]}),"\n",(0,r.jsx)(e.h3,{id:"key-physics-parameters",children:"Key Physics Parameters"}),"\n",(0,r.jsx)(e.h4,{id:"1-gravity",children:"1. Gravity"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Gravity"})," accelerates objects downward (typically -9.81 m/s\xb2 in Z direction)."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Configuration"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<physics type="ode">\n  <gravity>0 0 -9.81</gravity>  \x3c!-- X, Y, Z components --\x3e\n</physics>\n'})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Why it matters for humanoids"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Walking requires gravity to generate ground reaction forces"}),"\n",(0,r.jsx)(e.li,{children:"Balance control depends on gravitational torque"}),"\n",(0,r.jsx)(e.li,{children:"Falling dynamics must be realistic for safety testing"}),"\n"]}),"\n",(0,r.jsx)(e.h4,{id:"2-collision-detection",children:"2. Collision Detection"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Collision detection"})," prevents objects from penetrating each other."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Collision geometries"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Box"}),": Fast, good for simple shapes"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Sphere"}),": Very fast, good for round objects"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Mesh"}),": Accurate but slower (use for complex shapes)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Cylinder"}),": Good for limbs, links"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Example"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<link name="foot">\n  <collision name="foot_collision">\n    <geometry>\n      <box>\n        <size>0.15 0.08 0.02</size>  \x3c!-- Length, width, height --\x3e\n      </box>\n    </geometry>\n    <pose>0 0 -0.01 0 0 0</pose>  \x3c!-- Slightly below visual --\x3e\n  </collision>\n</link>\n'})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Best practice"}),": Collision geometry should be ",(0,r.jsx)(e.strong,{children:"simpler"})," than visual geometry (for performance)."]}),"\n",(0,r.jsx)(e.h4,{id:"3-friction",children:"3. Friction"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Friction"})," resists sliding motion. Critical for walking and manipulation."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Friction coefficients"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Static friction"})," (",(0,r.jsx)(e.code,{children:"mu1"}),"): Force to start sliding"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Dynamic friction"})," (",(0,r.jsx)(e.code,{children:"mu2"}),"): Force to keep sliding"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Typical values"}),":","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["Rubber on concrete: ",(0,r.jsx)(e.code,{children:"mu1=1.0"}),", ",(0,r.jsx)(e.code,{children:"mu2=0.8"})]}),"\n",(0,r.jsxs)(e.li,{children:["Metal on metal: ",(0,r.jsx)(e.code,{children:"mu1=0.5"}),", ",(0,r.jsx)(e.code,{children:"mu2=0.3"})]}),"\n",(0,r.jsxs)(e.li,{children:["Ice: ",(0,r.jsx)(e.code,{children:"mu1=0.1"}),", ",(0,r.jsx)(e.code,{children:"mu2=0.05"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Configuration"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<collision name="foot_collision">\n  <surface>\n    <friction>\n      <ode>\n        <mu>1.0</mu>        \x3c!-- Static friction --\x3e\n        <mu2>0.8</mu2>      \x3c!-- Dynamic friction --\x3e\n        <fdir1>0 0 0</fdir1> \x3c!-- Friction direction (anisotropic) --\x3e\n        <slip1>0.0</slip1>   \x3c!-- Slip in direction 1 --\x3e\n        <slip2>0.0</slip2>   \x3c!-- Slip in direction 2 --\x3e\n      </ode>\n    </friction>\n  </surface>\n</collision>\n'})}),"\n",(0,r.jsx)(e.h4,{id:"4-inertia",children:"4. Inertia"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Inertia"})," determines how objects resist rotational acceleration."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"For humanoid links"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Mass"}),": Total weight of link"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Center of mass"}),": Where mass is concentrated"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Inertia tensor"}),": Resistance to rotation about each axis"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Example (humanoid leg link)"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<link name="thigh">\n  <inertial>\n    <mass>2.5</mass>  \x3c!-- kg --\x3e\n    <pose>0 0 0.15 0 0 0</pose>  \x3c!-- Center of mass offset --\x3e\n    <inertia>\n      <ixx>0.05</ixx>  \x3c!-- Rotation about X-axis --\x3e\n      <iyy>0.05</iyy>  \x3c!-- Rotation about Y-axis --\x3e\n      <izz>0.01</izz>  \x3c!-- Rotation about Z-axis (smaller for cylindrical link) --\x3e\n      <ixy>0.0</ixy>   \x3c!-- Cross terms (usually 0 for symmetric objects) --\x3e\n      <ixz>0.0</ixz>\n      <iyz>0.0</iyz>\n    </inertia>\n  </inertial>\n</link>\n'})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Why inertia matters"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Walking dynamics depend on leg inertia"}),"\n",(0,r.jsx)(e.li,{children:"Balance control requires accurate center of mass"}),"\n",(0,r.jsx)(e.li,{children:"Manipulation forces depend on object inertia"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"solver-parameters",children:"Solver Parameters"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"ODE solver settings"})," control accuracy vs. performance:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:"<physics type=\"ode\">\n  <ode>\n    <solver>\n      <type>quick</type>      \x3c!-- 'quick' or 'world' --\x3e\n      <iters>10</iters>       \x3c!-- Solver iterations (more = more accurate, slower) --\x3e\n      <sor>1.4</sor>          \x3c!-- Successive Over-Relaxation (1.0 to 1.9) --\x3e\n      <use_dynamic_moi_rescaling>true</use_dynamic_moi_rescaling>\n    </solver>\n    <constraints>\n      <cfm>0.00001</cfm>      \x3c!-- Constraint Force Mixing (smaller = stiffer) --\x3e\n      <erp>0.2</erp>          \x3c!-- Error Reduction Parameter (0 to 1, higher = faster correction) --\x3e\n      <contact_max_correcting_vel>100.0</contact_max_correcting_vel>\n      <contact_surface_layer>0.001</contact_surface_layer>\n    </constraints>\n  </ode>\n</physics>\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Tuning guide"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"More iterations"})," (",(0,r.jsx)(e.code,{children:"iters=50"}),"): More accurate, slower"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Higher ERP"})," (",(0,r.jsx)(e.code,{children:"erp=0.8"}),"): Faster constraint correction, may cause jitter"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Lower CFM"})," (",(0,r.jsx)(e.code,{children:"cfm=0.000001"}),"): Stiffer contacts, more stable"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"part-2-hands-on-tutorial",children:"Part 2: Hands-On Tutorial"}),"\n",(0,r.jsx)(e.h3,{id:"project-simulate-humanoid-walking-dynamics",children:"Project: Simulate Humanoid Walking Dynamics"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Goal"}),": Create a simple humanoid model with realistic physics and simulate walking dynamics."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Tools"}),": Gazebo Classic 11, ROS 2 Humble, URDF"]}),"\n",(0,r.jsx)(e.h3,{id:"step-1-create-simple-humanoid-urdf",children:"Step 1: Create Simple Humanoid URDF"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"File"}),": ",(0,r.jsx)(e.code,{children:"models/simple_humanoid/model.urdf"})]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="simple_humanoid">\n  \n  \x3c!-- Base Link (Torso) --\x3e\n  <link name="torso">\n    <visual name="torso_visual">\n      <geometry>\n        <box size="0.3 0.2 0.4"/>\n      </geometry>\n      <material name="blue">\n        <color rgba="0 0 1 1"/>\n      </material>\n    </visual>\n    <collision name="torso_collision">\n      <geometry>\n        <box size="0.3 0.2 0.4"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="10.0"/>\n      <origin xyz="0 0 0" rpy="0 0 0"/>\n      <inertia ixx="0.2" ixy="0" ixz="0" iyy="0.15" iyz="0" izz="0.15"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Left Leg --\x3e\n  <link name="left_thigh">\n    <visual name="thigh_visual">\n      <geometry>\n        <cylinder radius="0.05" length="0.3"/>\n      </geometry>\n      <material name="red">\n        <color rgba="1 0 0 1"/>\n      </material>\n    </visual>\n    <collision name="thigh_collision">\n      <geometry>\n        <cylinder radius="0.05" length="0.3"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="2.0"/>\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/>\n      <inertia ixx="0.02" ixy="0" ixz="0" iyy="0.02" iyz="0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  <link name="left_shank">\n    <visual name="shank_visual">\n      <geometry>\n        <cylinder radius="0.04" length="0.3"/>\n      </geometry>\n      <material name="red">\n        <color rgba="1 0 0 1"/>\n      </material>\n    </visual>\n    <collision name="shank_collision">\n      <geometry>\n        <cylinder radius="0.04" length="0.3"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="1.5"/>\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/>\n      <inertia ixx="0.015" ixy="0" ixz="0" iyy="0.015" iyz="0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  <link name="left_foot">\n    <visual name="foot_visual">\n      <geometry>\n        <box size="0.15 0.08 0.02"/>\n      </geometry>\n      <material name="black">\n        <color rgba="0 0 0 1"/>\n      </material>\n    </visual>\n    <collision name="foot_collision">\n      <geometry>\n        <box size="0.15 0.08 0.02"/>\n      </geometry>\n      <surface>\n        <friction>\n          <ode>\n            <mu>1.0</mu>\n            <mu2>0.8</mu2>\n          </ode>\n        </friction>\n      </surface>\n    </collision>\n    <inertial>\n      <mass value="0.5"/>\n      <origin xyz="0 0 -0.01" rpy="0 0 0"/>\n      <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.002"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Joints --\x3e\n  <joint name="left_hip" type="revolute">\n    <parent link="torso"/>\n    <child link="left_thigh"/>\n    <origin xyz="0.1 0 -0.2" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="-1.57" upper="1.57" effort="100" velocity="10"/>\n  </joint>\n\n  <joint name="left_knee" type="revolute">\n    <parent link="left_thigh"/>\n    <child link="left_shank"/>\n    <origin xyz="0 0 -0.3" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="0" upper="3.14" effort="100" velocity="10"/>\n  </joint>\n\n  <joint name="left_ankle" type="revolute">\n    <parent link="left_shank"/>\n    <child link="left_foot"/>\n    <origin xyz="0 0 -0.3" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="-0.5" upper="0.5" effort="50" velocity="5"/>\n  </joint>\n\n  \x3c!-- Right Leg (mirror of left) --\x3e\n  <link name="right_thigh">\n    <visual name="thigh_visual">\n      <geometry>\n        <cylinder radius="0.05" length="0.3"/>\n      </geometry>\n      <material name="red">\n        <color rgba="1 0 0 1"/>\n      </material>\n    </visual>\n    <collision name="thigh_collision">\n      <geometry>\n        <cylinder radius="0.05" length="0.3"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="2.0"/>\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/>\n      <inertia ixx="0.02" ixy="0" ixz="0" iyy="0.02" iyz="0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  <link name="right_shank">\n    <visual name="shank_visual">\n      <geometry>\n        <cylinder radius="0.04" length="0.3"/>\n      </geometry>\n      <material name="red">\n        <color rgba="1 0 0 1"/>\n      </material>\n    </visual>\n    <collision name="shank_collision">\n      <geometry>\n        <cylinder radius="0.04" length="0.3"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="1.5"/>\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/>\n      <inertia ixx="0.015" ixy="0" ixz="0" iyy="0.015" iyz="0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  <link name="right_foot">\n    <visual name="foot_visual">\n      <geometry>\n        <box size="0.15 0.08 0.02"/>\n      </geometry>\n      <material name="black">\n        <color rgba="0 0 0 1"/>\n      </material>\n    </visual>\n    <collision name="foot_collision">\n      <geometry>\n        <box size="0.15 0.08 0.02"/>\n      </geometry>\n      <surface>\n        <friction>\n          <ode>\n            <mu>1.0</mu>\n            <mu2>0.8</mu2>\n          </ode>\n        </friction>\n      </surface>\n    </collision>\n    <inertial>\n      <mass value="0.5"/>\n      <origin xyz="0 0 -0.01" rpy="0 0 0"/>\n      <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.002"/>\n    </inertial>\n  </link>\n\n  <joint name="right_hip" type="revolute">\n    <parent link="torso"/>\n    <child link="right_thigh"/>\n    <origin xyz="-0.1 0 -0.2" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="-1.57" upper="1.57" effort="100" velocity="10"/>\n  </joint>\n\n  <joint name="right_knee" type="revolute">\n    <parent link="right_thigh"/>\n    <child link="right_shank"/>\n    <origin xyz="0 0 -0.3" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="0" upper="3.14" effort="100" velocity="10"/>\n  </joint>\n\n  <joint name="right_ankle" type="revolute">\n    <parent link="right_shank"/>\n    <child link="right_foot"/>\n    <origin xyz="0 0 -0.3" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="-0.5" upper="0.5" effort="50" velocity="5"/>\n  </joint>\n\n</robot>\n'})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Key features"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Realistic masses"}),": Torso (10 kg), thighs (2 kg each), shanks (1.5 kg), feet (0.5 kg)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Proper inertia"}),": Cylindrical links have higher inertia about length axis"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Friction on feet"}),": ",(0,r.jsx)(e.code,{children:"mu=1.0"})," prevents sliding"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Joint limits"}),": Realistic ranges for hip, knee, ankle"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"step-2-create-gazebo-world-with-physics",children:"Step 2: Create Gazebo World with Physics"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"File"}),": ",(0,r.jsx)(e.code,{children:"worlds/humanoid_physics.world"})]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.6">\n  <world name="humanoid_physics">\n    \n    \x3c!-- Physics Configuration --\x3e\n    <physics type="ode">\n      <gravity>0 0 -9.81</gravity>\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <real_time_update_rate>1000</real_time_update_rate>\n      \n      <ode>\n        <solver>\n          <type>quick</type>\n          <iters>50</iters>  \x3c!-- Higher for stability --\x3e\n          <sor>1.4</sor>\n        </solver>\n        <constraints>\n          <cfm>0.00001</cfm>\n          <erp>0.2</erp>\n          <contact_max_correcting_vel>100.0</contact_max_correcting_vel>\n          <contact_surface_layer>0.001</contact_surface_layer>\n        </constraints>\n      </ode>\n    </physics>\n\n    \x3c!-- Lighting --\x3e\n    <include>\n      <uri>model://sun</uri>\n    </include>\n\n    \x3c!-- Ground Plane with Friction --\x3e\n    <model name="ground_plane">\n      <static>true</static>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n          <surface>\n            <friction>\n              <ode>\n                <mu>1.0</mu>\n                <mu2>0.8</mu2>\n              </ode>\n            </friction>\n          </surface>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n          <material>\n            <script>\n              <name>Gazebo/Grey</name>\n              <uri>file://media/materials/scripts/gazebo.material</uri>\n            <\/script>\n          </material>\n        </visual>\n      </link>\n    </model>\n\n  </world>\n</sdf>\n'})}),"\n",(0,r.jsx)(e.h3,{id:"step-3-launch-humanoid-in-gazebo",children:"Step 3: Launch Humanoid in Gazebo"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"File"}),": ",(0,r.jsx)(e.code,{children:"launch/humanoid_physics.launch.py"})]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\n\"\"\"\nLaunch humanoid robot in Gazebo with physics simulation\nROS 2 Humble | Gazebo Classic 11\n\"\"\"\nfrom launch import LaunchDescription\nfrom launch.actions import ExecuteProcess, DeclareLaunchArgument\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\nimport os\n\ndef generate_launch_description():\n    pkg_share = FindPackageShare('gazebo_worlds').find('gazebo_worlds')\n    world_path = os.path.join(pkg_share, 'worlds', 'humanoid_physics.world')\n    urdf_path = os.path.join(pkg_share, 'models', 'simple_humanoid', 'model.urdf')\n\n    return LaunchDescription([\n        # Launch Gazebo\n        ExecuteProcess(\n            cmd=['gazebo', '--verbose', world_path],\n            output='screen'\n        ),\n        \n        # Spawn humanoid robot\n        Node(\n            package='gazebo_ros',\n            executable='spawn_entity.py',\n            arguments=['-entity', 'humanoid', '-file', urdf_path, '-x', '0', '-y', '0', '-z', '1.0'],\n            output='screen'\n        ),\n        \n        # Robot state publisher (for RViz2 visualization)\n        Node(\n            package='robot_state_publisher',\n            executable='robot_state_publisher',\n            name='robot_state_publisher',\n            arguments=[urdf_path],\n            output='screen'\n        )\n    ])\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Build and launch"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"cd ~/gazebo_ws\ncolcon build --packages-select gazebo_worlds\nsource install/setup.bash\n\nros2 launch gazebo_worlds humanoid_physics.launch.py\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Expected Result"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Humanoid spawns at height z=1.0 m"}),"\n",(0,r.jsx)(e.li,{children:"Robot falls due to gravity"}),"\n",(0,r.jsx)(e.li,{children:"Feet contact ground with friction"}),"\n",(0,r.jsx)(e.li,{children:"Robot should stabilize (not penetrate ground)"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"step-4-test-physics-parameters",children:"Step 4: Test Physics Parameters"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Modify friction"})," (in URDF foot collision):"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:"<friction>\n  <ode>\n    <mu>0.1</mu>  \x3c!-- Low friction (like ice) --\x3e\n    <mu2>0.05</mu2>\n  </ode>\n</friction>\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Result"}),": Robot slides when landing (unstable)."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Modify gravity"})," (in world file):"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:"<gravity>0 0 -4.9</gravity>  \x3c!-- Half gravity (like moon) --\x3e\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Result"}),": Robot falls slower, easier to balance."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Modify solver iterations"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:"<iters>10</iters>  \x3c!-- Lower iterations --\x3e\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Result"}),": May see jittering or penetration (less stable)."]}),"\n",(0,r.jsx)(e.h3,{id:"step-5-debugging-physics-issues",children:"Step 5: Debugging Physics Issues"}),"\n",(0,r.jsx)(e.h4,{id:"issue-1-objects-penetrating-ground",children:"Issue 1: Objects Penetrating Ground"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Symptoms"}),": Robot sinks into ground plane"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Solutions"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:"\x3c!-- Increase contact surface layer --\x3e\n<contact_surface_layer>0.01</contact_surface_layer>\n\n\x3c!-- Increase solver iterations --\x3e\n<iters>100</iters>\n\n\x3c!-- Reduce timestep for more accuracy --\x3e\n<max_step_size>0.0001</max_step_size>\n"})}),"\n",(0,r.jsx)(e.h4,{id:"issue-2-jitteringshaking",children:"Issue 2: Jittering/Shaking"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Symptoms"}),": Robot vibrates when stationary"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Solutions"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Reduce ERP (slower correction) --\x3e\n<erp>0.1</erp>\n\n\x3c!-- Increase CFM (softer contacts) --\x3e\n<cfm>0.0001</cfm>\n\n\x3c!-- Increase damping in joints --\x3e\n<joint name="left_hip" type="revolute">\n  <dynamics damping="1.0" friction="0.1"/>\n</joint>\n'})}),"\n",(0,r.jsx)(e.h4,{id:"issue-3-unrealistic-bouncing",children:"Issue 3: Unrealistic Bouncing"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Symptoms"}),": Objects bounce too much on contact"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Solutions"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Add restitution (bounciness) control --\x3e\n<collision name="foot_collision">\n  <surface>\n    <bounce>\n      <restitution_coefficient>0.0</restitution_coefficient>  \x3c!-- 0 = no bounce --\x3e\n    </bounce>\n  </surface>\n</collision>\n'})}),"\n",(0,r.jsx)(e.h2,{id:"part-3-advanced-topics-optional",children:"Part 3: Advanced Topics (Optional)"}),"\n",(0,r.jsx)(e.h3,{id:"bullet-physics-engine",children:"Bullet Physics Engine"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Switch to Bullet"})," (alternative to ODE):"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<physics type="bullet">\n  <gravity>0 0 -9.81</gravity>\n  <bullet>\n    <solver>\n      <type>SequentialImpulse</type>\n      <iters>50</iters>\n      <sor>1.0</sor>\n    </solver>\n    <constraints>\n      <cfm>0.00001</cfm>\n      <erp>0.2</erp>\n    </constraints>\n  </bullet>\n</physics>\n'})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"When to use Bullet"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"More accurate collision detection"}),"\n",(0,r.jsx)(e.li,{children:"Better for soft bodies"}),"\n",(0,r.jsx)(e.li,{children:"Slightly slower than ODE"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"contact-forces-visualization",children:"Contact Forces Visualization"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Enable contact visualization"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"# In Gazebo GUI: View \u2192 Contacts\n# Or via ROS 2:\nros2 topic echo /gazebo/default/physics/contacts\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Useful for debugging"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"See which links are in contact"}),"\n",(0,r.jsx)(e.li,{children:"Verify contact forces"}),"\n",(0,r.jsx)(e.li,{children:"Debug collision geometries"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"integration-with-capstone",children:"Integration with Capstone"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"How this chapter contributes"})," to the Week 13 autonomous humanoid:"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Walking dynamics"}),": Capstone humanoid will walk using physics-accurate simulation"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Balance control"}),": Balance algorithms depend on accurate center of mass and inertia"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Manipulation"}),": Grasping objects requires realistic friction and contact forces"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Fall recovery"}),": Testing fall scenarios safely requires accurate physics"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"Understanding physics parameters now is essential for tuning the capstone simulation."}),"\n",(0,r.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(e.p,{children:"You learned:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\u2705 Configured ",(0,r.jsx)(e.strong,{children:"physics engines"})," (ODE) for humanoid dynamics"]}),"\n",(0,r.jsxs)(e.li,{children:["\u2705 Modeled ",(0,r.jsx)(e.strong,{children:"gravity, friction, and collisions"})," in URDF"]}),"\n",(0,r.jsxs)(e.li,{children:["\u2705 Created ",(0,r.jsx)(e.strong,{children:"realistic humanoid model"})," with proper masses and inertia"]}),"\n",(0,r.jsxs)(e.li,{children:["\u2705 Simulated ",(0,r.jsx)(e.strong,{children:"walking dynamics"})," and verified physics accuracy"]}),"\n",(0,r.jsxs)(e.li,{children:["\u2705 Debugged ",(0,r.jsx)(e.strong,{children:"common physics artifacts"})," (penetration, jitter)"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Next steps"}),": In Chapter 2.3, you'll add sensors (cameras, LiDAR, IMUs) to your humanoid model."]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,r.jsx)(e.h3,{id:"exercise-1-friction-experiment-required",children:"Exercise 1: Friction Experiment (Required)"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Objective"}),": Understand how friction affects humanoid stability."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Tasks"}),":"]}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["Launch humanoid with default friction (",(0,r.jsx)(e.code,{children:"mu=1.0"}),")"]}),"\n",(0,r.jsx)(e.li,{children:"Record if robot stabilizes after falling"}),"\n",(0,r.jsxs)(e.li,{children:["Change friction to ",(0,r.jsx)(e.code,{children:"mu=0.1"})," (low friction)"]}),"\n",(0,r.jsx)(e.li,{children:"Observe robot sliding/unstable behavior"}),"\n",(0,r.jsxs)(e.li,{children:["Change friction to ",(0,r.jsx)(e.code,{children:"mu=2.0"})," (high friction)"]}),"\n",(0,r.jsx)(e.li,{children:"Compare stability across friction values"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Questions"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"What friction value gives best stability?"}),"\n",(0,r.jsx)(e.li,{children:"Why does low friction cause sliding?"}),"\n",(0,r.jsx)(e.li,{children:"How does friction affect walking?"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Acceptance Criteria"}),":"]}),"\n",(0,r.jsxs)(e.ul,{className:"contains-task-list",children:["\n",(0,r.jsxs)(e.li,{className:"task-list-item",children:[(0,r.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Tested 3 different friction values"]}),"\n",(0,r.jsxs)(e.li,{className:"task-list-item",children:[(0,r.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Documented behavior for each value"]}),"\n",(0,r.jsxs)(e.li,{className:"task-list-item",children:[(0,r.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Explained relationship between friction and stability"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Estimated Time"}),": 45 minutes"]}),"\n",(0,r.jsx)(e.h3,{id:"exercise-2-inertia-tuning-required",children:"Exercise 2: Inertia Tuning (Required)"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Objective"}),": Understand how inertia affects robot dynamics."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Tasks"}),":"]}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["Modify thigh link inertia (increase ",(0,r.jsx)(e.code,{children:"izz"})," by 10x)"]}),"\n",(0,r.jsx)(e.li,{children:"Launch robot and observe falling behavior"}),"\n",(0,r.jsx)(e.li,{children:"Compare to original inertia values"}),"\n",(0,r.jsx)(e.li,{children:"Modify center of mass position (move upward)"}),"\n",(0,r.jsx)(e.li,{children:"Observe effect on balance"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Questions"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"How does higher inertia affect rotation?"}),"\n",(0,r.jsx)(e.li,{children:"Why does center of mass position matter?"}),"\n",(0,r.jsx)(e.li,{children:"What inertia values are realistic for humanoid links?"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Estimated Time"}),": 60 minutes"]}),"\n",(0,r.jsx)(e.h3,{id:"exercise-3-physics-solver-tuning-challenge",children:"Exercise 3: Physics Solver Tuning (Challenge)"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Objective"}),": Optimize solver parameters for stability vs. performance."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Tasks"}),":"]}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["Test with ",(0,r.jsx)(e.code,{children:"iters=10"})," (low accuracy)"]}),"\n",(0,r.jsxs)(e.li,{children:["Test with ",(0,r.jsx)(e.code,{children:"iters=100"})," (high accuracy)"]}),"\n",(0,r.jsx)(e.li,{children:"Measure simulation speed (FPS) for each"}),"\n",(0,r.jsx)(e.li,{children:"Find minimum iterations for stable simulation"}),"\n",(0,r.jsx)(e.li,{children:"Document performance vs. accuracy tradeoff"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Metrics"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Simulation FPS (higher = faster)"}),"\n",(0,r.jsx)(e.li,{children:"Physics stability (no jitter/penetration)"}),"\n",(0,r.jsx)(e.li,{children:"CPU usage"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Estimated Time"}),": 90 minutes"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"additional-resources",children:"Additional Resources"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"https://www.ode.org/",children:"ODE Documentation"})," - Physics engine reference"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"https://gazebosim.org/docs/latest/physics_configuration",children:"Gazebo Physics Tutorial"})," - Configuration guide"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"http://wiki.ros.org/urdf/XML/link",children:"URDF Physics"})," - Inertia and collision modeling"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"https://www.engineeringtoolbox.com/friction-coefficients-d_778.html",children:"Friction Coefficients"})," - Real-world values"]}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Next"}),": [Chapter 2.3: Sensor Simulation (LiDAR, Cameras, IMUs) \u2192](chapter-2 to 3.md)"]})]})}function h(n={}){const{wrapper:e}={...(0,l.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}}}]);