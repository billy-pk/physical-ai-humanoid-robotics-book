"use strict";(globalThis.webpackChunkfrontend=globalThis.webpackChunkfrontend||[]).push([[263],{2779:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module-1/chapter-1-2","title":"1.2 Robotics Fundamentals","description":"Now that we understand AI fundamentals, let\'s explore the physical side of Physical AI: robotics. This chapter covers core robotics concepts\u2014kinematics, dynamics, control theory\u2014essential for understanding how humanoid robots move and interact with the world.","source":"@site/docs/module-1/chapter-1-2.md","sourceDirName":"module-1","slug":"/module-1/chapter-1-2","permalink":"/physical-ai-humanoid-robotics-book/docs/module-1/chapter-1-2","draft":false,"unlisted":false,"editUrl":"https://github.com/billy-pk/physical-ai-humanoid-robotics-book/tree/main/frontend/docs/module-1/chapter-1-2.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"1.2 Robotics Fundamentals"},"sidebar":"defaultSidebar","previous":{"title":"1.1 Fundamentals of Artificial Intelligence","permalink":"/physical-ai-humanoid-robotics-book/docs/module-1/chapter-1-1"},"next":{"title":"1.3 Sensors and Actuators","permalink":"/physical-ai-humanoid-robotics-book/docs/module-1/chapter-1-3"}}');var r=i(4848),o=i(8453);const t={sidebar_position:2,title:"1.2 Robotics Fundamentals"},l="Chapter 1.2: Robotics Fundamentals",a={},c=[{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Robot Anatomy: Links, Joints, and Degrees of Freedom",id:"robot-anatomy-links-joints-and-degrees-of-freedom",level:2},{value:"Basic Components",id:"basic-components",level:3},{value:"Example: Human Arm vs. Robot Arm",id:"example-human-arm-vs-robot-arm",level:3},{value:"Task Space vs. Joint Space",id:"task-space-vs-joint-space",level:3},{value:"Kinematics: The Geometry of Motion",id:"kinematics-the-geometry-of-motion",level:2},{value:"Forward Kinematics (FK)",id:"forward-kinematics-fk",level:3},{value:"Inverse Kinematics (IK)",id:"inverse-kinematics-ik",level:3},{value:"Dynamics: Forces and Motion",id:"dynamics-forces-and-motion",level:2},{value:"Key Concepts",id:"key-concepts",level:3},{value:"Why Dynamics Matter",id:"why-dynamics-matter",level:3},{value:"Example: Gravity Compensation",id:"example-gravity-compensation",level:3},{value:"Control Systems: Making Robots Move Accurately",id:"control-systems-making-robots-move-accurately",level:2},{value:"Control Loop Architecture",id:"control-loop-architecture",level:3},{value:"PID Control",id:"pid-control",level:3},{value:"Challenges in Humanoid Robot Control",id:"challenges-in-humanoid-robot-control",level:3},{value:"Bipedal Locomotion: Walking on Two Legs",id:"bipedal-locomotion-walking-on-two-legs",level:2},{value:"The Balance Challenge",id:"the-balance-challenge",level:3},{value:"Gait Phases",id:"gait-phases",level:3},{value:"Walking Controllers",id:"walking-controllers",level:3},{value:"Exercises",id:"exercises",level:2},{value:"1. Degrees of Freedom",id:"1-degrees-of-freedom",level:3},{value:"2. Forward Kinematics Calculation",id:"2-forward-kinematics-calculation",level:3},{value:"3. Inverse Kinematics Challenge",id:"3-inverse-kinematics-challenge",level:3},{value:"4. PID Tuning",id:"4-pid-tuning",level:3},{value:"5. Code Challenge",id:"5-code-challenge",level:3},{value:"6. Walking Stability",id:"6-walking-stability",level:3},{value:"7. Design Exercise",id:"7-design-exercise",level:3},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Further Reading",id:"further-reading",level:2}];function d(n){const e={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"chapter-12-robotics-fundamentals",children:"Chapter 1.2: Robotics Fundamentals"})}),"\n",(0,r.jsxs)(e.p,{children:["Now that we understand AI fundamentals, let's explore the physical side of Physical AI: ",(0,r.jsx)(e.strong,{children:"robotics"}),". This chapter covers core robotics concepts\u2014kinematics, dynamics, control theory\u2014essential for understanding how humanoid robots move and interact with the world."]}),"\n",(0,r.jsx)(e.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,r.jsx)(e.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Understand"})," robot anatomy: links, joints, degrees of freedom (DOF)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Define"})," forward and inverse kinematics and their applications"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Explain"})," robot dynamics: forces, torques, and equations of motion"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Describe"})," control system fundamentals (PID, feedforward, feedback)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Apply"})," basic kinematic calculations for simple robot arms"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Recognize"})," challenges unique to bipedal humanoid robots"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"robot-anatomy-links-joints-and-degrees-of-freedom",children:"Robot Anatomy: Links, Joints, and Degrees of Freedom"}),"\n",(0,r.jsx)(e.p,{children:"A robot's physical structure determines what motions it can perform. Understanding this anatomy is foundational to robotics."}),"\n",(0,r.jsx)(e.h3,{id:"basic-components",children:"Basic Components"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Links (Rigid Bodies)"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Physical segments of the robot (e.g., upper arm, forearm, thigh)"}),"\n",(0,r.jsx)(e.li,{children:"Connected by joints"}),"\n",(0,r.jsx)(e.li,{children:"Have mass, inertia, and geometry"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Joints (Connections)"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Allow relative motion between links"}),"\n",(0,r.jsxs)(e.li,{children:["Types:","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Revolute (R)"}),": Rotation around an axis (like human elbow)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Prismatic (P)"}),": Linear sliding motion (like a drawer)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Spherical"}),": 3-DOF ball-and-socket (like human shoulder)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Fixed"}),": No motion (welded connection)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Degrees of Freedom (DOF)"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Number of independent ways a robot can move"}),"\n",(0,r.jsxs)(e.li,{children:["Each joint contributes DOF:","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Revolute joint: 1 DOF"}),"\n",(0,r.jsx)(e.li,{children:"Prismatic joint: 1 DOF"}),"\n",(0,r.jsx)(e.li,{children:"Spherical joint: 3 DOF"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"example-human-arm-vs-robot-arm",children:"Example: Human Arm vs. Robot Arm"}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Segment"}),(0,r.jsx)(e.th,{children:"Human"}),(0,r.jsx)(e.th,{children:"Typical Robot Arm"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Shoulder"})}),(0,r.jsx)(e.td,{children:"3 DOF (spherical)"}),(0,r.jsx)(e.td,{children:"3 DOF (3 revolute joints)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Elbow"})}),(0,r.jsx)(e.td,{children:"1 DOF (hinge)"}),(0,r.jsx)(e.td,{children:"1 DOF (revolute)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Wrist"})}),(0,r.jsx)(e.td,{children:"3 DOF (complex)"}),(0,r.jsx)(e.td,{children:"3 DOF (3 revolute joints)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Total DOF"})}),(0,r.jsx)(e.td,{children:"7 DOF per arm"}),(0,r.jsx)(e.td,{children:"7 DOF per arm"})]})]})]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Humanoid robots"})," typically have:"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Total"}),": 25-40 DOF for full body"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Legs"}),": 6 DOF per leg (hip: 3, knee: 1, ankle: 2)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Arms"}),": 7 DOF per arm"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Torso"}),": 1-3 DOF"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Head"}),": 2-3 DOF (pan, tilt, sometimes roll)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Hands"}),": 5-20 DOF depending on dexterity"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"task-space-vs-joint-space",children:"Task Space vs. Joint Space"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Joint Space"}),": Describes robot configuration using joint angles (\u03b8\u2081, \u03b8\u2082, ..., \u03b8\u2099)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Task Space (Cartesian Space)"}),": Describes end-effector position and orientation in 3D space (x, y, z, roll, pitch, yaw)"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Example"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"Joint Space: [shoulder: 45\xb0, elbow: 90\xb0, wrist: 30\xb0]\nTask Space: hand position at (0.5m, 0.3m, 1.2m)\n"})}),"\n",(0,r.jsx)(e.h2,{id:"kinematics-the-geometry-of-motion",children:"Kinematics: The Geometry of Motion"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Kinematics"})," studies motion without considering forces. For robots, it's about relating joint angles to end-effector position."]}),"\n",(0,r.jsx)(e.h3,{id:"forward-kinematics-fk",children:"Forward Kinematics (FK)"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Definition"}),": Given joint angles, compute end-effector position and orientation."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Formula"}),": Position = f(joint angles)"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Example - 2-Link Planar Robot Arm"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"Link 1 length: L\u2081 = 1.0m, angle: \u03b8\u2081\nLink 2 length: L\u2082 = 0.8m, angle: \u03b8\u2082\n\nEnd-effector position:\nx = L\u2081\xb7cos(\u03b8\u2081) + L\u2082\xb7cos(\u03b8\u2081 + \u03b8\u2082)\ny = L\u2081\xb7sin(\u03b8\u2081) + L\u2082\xb7sin(\u03b8\u2081 + \u03b8\u2082)\n\nIf \u03b8\u2081 = 30\xb0, \u03b8\u2082 = 45\xb0:\nx = 1.0\xb7cos(30\xb0) + 0.8\xb7cos(75\xb0) \u2248 1.073m\ny = 1.0\xb7sin(30\xb0) + 0.8\xb7sin(75\xb0) \u2248 1.273m\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Code Example"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'import numpy as np\n\ndef forward_kinematics_2link(theta1, theta2, L1=1.0, L2=0.8):\n    """\n    Compute end-effector position for 2-link planar arm.\n\n    Args:\n        theta1: First joint angle (radians)\n        theta2: Second joint angle (radians)\n        L1: Length of first link (meters)\n        L2: Length of second link (meters)\n\n    Returns:\n        (x, y) position of end-effector\n    """\n    x = L1 * np.cos(theta1) + L2 * np.cos(theta1 + theta2)\n    y = L1 * np.sin(theta1) + L2 * np.sin(theta1 + theta2)\n    return x, y\n\n# Example usage\ntheta1 = np.deg2rad(30)  # Convert degrees to radians\ntheta2 = np.deg2rad(45)\nx, y = forward_kinematics_2link(theta1, theta2)\nprint(f"End-effector position: ({x:.3f}m, {y:.3f}m)")\n# Output: End-effector position: (1.073m, 1.273m)\n'})}),"\n",(0,r.jsx)(e.h3,{id:"inverse-kinematics-ik",children:"Inverse Kinematics (IK)"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Definition"}),": Given desired end-effector position, compute required joint angles."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Formula"}),": Joint angles = f\u207b\xb9(desired position)"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Challenge"}),": Much harder than FK!"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["May have ",(0,r.jsx)(e.strong,{children:"multiple solutions"})," (elbow up vs. elbow down)"]}),"\n",(0,r.jsxs)(e.li,{children:["May have ",(0,r.jsx)(e.strong,{children:"no solution"})," (target out of reach)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Computationally expensive"})," for complex robots"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Example - 2-Link Planar Robot (Analytical Solution)"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'def inverse_kinematics_2link(x, y, L1=1.0, L2=0.8, elbow_up=True):\n    """\n    Compute joint angles for desired end-effector position.\n\n    Args:\n        x, y: Desired end-effector position\n        L1, L2: Link lengths\n        elbow_up: If True, use elbow-up solution\n\n    Returns:\n        (theta1, theta2) joint angles in radians\n\n    Raises:\n        ValueError: If position is unreachable\n    """\n    # Check if position is reachable\n    distance = np.sqrt(x**2 + y**2)\n    if distance > L1 + L2 or distance < abs(L1 - L2):\n        raise ValueError("Position unreachable!")\n\n    # Law of cosines for theta2\n    cos_theta2 = (x**2 + y**2 - L1**2 - L2**2) / (2 * L1 * L2)\n    cos_theta2 = np.clip(cos_theta2, -1, 1)  # Numerical stability\n\n    if elbow_up:\n        theta2 = np.arccos(cos_theta2)\n    else:\n        theta2 = -np.arccos(cos_theta2)\n\n    # Solve for theta1\n    k1 = L1 + L2 * np.cos(theta2)\n    k2 = L2 * np.sin(theta2)\n    theta1 = np.arctan2(y, x) - np.arctan2(k2, k1)\n\n    return theta1, theta2\n\n# Example usage\ntarget_x, target_y = 1.5, 0.5\ntheta1, theta2 = inverse_kinematics_2link(target_x, target_y)\nprint(f"Joint angles: \u03b8\u2081={np.rad2deg(theta1):.1f}\xb0, \u03b8\u2082={np.rad2deg(theta2):.1f}\xb0")\n\n# Verify with forward kinematics\nx_check, y_check = forward_kinematics_2link(theta1, theta2)\nprint(f"Verification: ({x_check:.3f}, {y_check:.3f}) \u2248 ({target_x}, {target_y})")\n'})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"For Humanoid Robots"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["IK is ",(0,r.jsx)(e.strong,{children:"critical"})," for task execution (reach to a point, place foot)"]}),"\n",(0,r.jsxs)(e.li,{children:["Usually solved ",(0,r.jsx)(e.strong,{children:"numerically"})," (optimization, Jacobian methods)"]}),"\n",(0,r.jsx)(e.li,{children:"Real-time requirements demand fast IK solvers"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"dynamics-forces-and-motion",children:"Dynamics: Forces and Motion"}),"\n",(0,r.jsxs)(e.p,{children:["While kinematics ignores forces, ",(0,r.jsx)(e.strong,{children:"dynamics"})," explicitly models them using Newton's laws."]}),"\n",(0,r.jsx)(e.h3,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Newton's Second Law"}),": F = ma (Force = mass \xd7 acceleration)"]}),"\n",(0,r.jsxs)(e.p,{children:["For rotational motion: ",(0,r.jsx)(e.strong,{children:"\u03c4 = I\xb7\u03b1"})," (Torque = inertia \xd7 angular acceleration)"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Robot Dynamics Equation"})," (Lagrangian formulation):"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"\u03c4 = M(q)\xb7q\u0308 + C(q, q\u0307)\xb7q\u0307 + G(q)\n\nWhere:\n\u03c4 = Joint torques (what motors must produce)\nM(q) = Mass/inertia matrix (depends on configuration q)\nC(q, q\u0307) = Coriolis and centrifugal terms (velocity-dependent)\nG(q) = Gravity terms\nq = Joint positions, q\u0307 = velocities, q\u0308 = accelerations\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Forward Dynamics"}),": Given torques \u2192 compute accelerations\n",(0,r.jsx)(e.strong,{children:"Inverse Dynamics"}),": Given desired motion \u2192 compute required torques"]}),"\n",(0,r.jsx)(e.h3,{id:"why-dynamics-matter",children:"Why Dynamics Matter"}),"\n",(0,r.jsx)(e.p,{children:"For humanoid robots, understanding dynamics is essential for:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Motor Selection"}),": Knowing required torques helps choose appropriate actuators"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Control"}),": Feedforward control uses inverse dynamics to compensate for gravity and inertia"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Simulation"}),": Predicting how robot will move under applied forces"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Energy Efficiency"}),": Optimal trajectories minimize energy consumption"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"example-gravity-compensation",children:"Example: Gravity Compensation"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'def gravity_torque_single_joint(mass, length, theta):\n    """\n    Calculate torque needed to hold a link against gravity.\n\n    Args:\n        mass: Link mass (kg)\n        length: Distance from joint to center of mass (m)\n        theta: Joint angle from horizontal (radians)\n\n    Returns:\n        Required torque (N\xb7m)\n    """\n    g = 9.81  # Gravity (m/s\xb2)\n    torque = mass * g * length * np.cos(theta)\n    return torque\n\n# Example: Humanoid arm link\n# Mass: 2kg, center of mass 0.3m from shoulder, angle 45\xb0 from horizontal\narm_mass = 2.0\narm_length = 0.3\narm_angle = np.deg2rad(45)\n\ntorque_needed = gravity_torque_single_joint(arm_mass, arm_length, arm_angle)\nprint(f"Torque to hold arm: {torque_needed:.2f} N\xb7m")\n# Output: ~4.16 N\xb7m\n'})}),"\n",(0,r.jsxs)(e.p,{children:["This simple calculation shows why robot joints need ",(0,r.jsx)(e.strong,{children:"continuous torque"})," just to hold position against gravity!"]}),"\n",(0,r.jsx)(e.h2,{id:"control-systems-making-robots-move-accurately",children:"Control Systems: Making Robots Move Accurately"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Control systems"})," ensure robots follow desired trajectories despite disturbances, model errors, and uncertainties."]}),"\n",(0,r.jsx)(e.h3,{id:"control-loop-architecture",children:"Control Loop Architecture"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"Desired State \u2192 [Controller] \u2192 Motor Commands \u2192 [Robot] \u2192 Actual State\n                      \u2191                                      \u2193\n                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Feedback (Sensors) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,r.jsx)(e.h3,{id:"pid-control",children:"PID Control"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"PID (Proportional-Integral-Derivative)"})," is the most common control algorithm in robotics."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Formula"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"u(t) = K\u209a\xb7e(t) + K\u1d62\xb7\u222be(t)dt + K\u2090\xb7de(t)/dt\n\nWhere:\nu(t) = Control output (motor command)\ne(t) = Error (desired - actual)\nK\u209a = Proportional gain (reacts to current error)\nK\u1d62 = Integral gain (eliminates steady-state error)\nK\u2090 = Derivative gain (dampens oscillations)\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Components"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"P (Proportional)"}),": Larger error \u2192 larger correction (fast response, but may overshoot)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"I (Integral)"}),": Accumulates error over time (eliminates bias, but can cause instability)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"D (Derivative)"}),": Responds to rate of error change (reduces overshoot, adds damping)"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Code Example"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'class PIDController:\n    """Simple PID controller for joint position control."""\n\n    def __init__(self, Kp, Ki, Kd, dt):\n        """\n        Initialize PID controller.\n\n        Args:\n            Kp, Ki, Kd: PID gains\n            dt: Time step (seconds)\n        """\n        self.Kp = Kp\n        self.Ki = Ki\n        self.Kd = Kd\n        self.dt = dt\n\n        self.integral = 0.0\n        self.prev_error = 0.0\n\n    def compute(self, setpoint, measured_value):\n        """\n        Compute control output.\n\n        Args:\n            setpoint: Desired value\n            measured_value: Current value\n\n        Returns:\n            Control output\n        """\n        # Error\n        error = setpoint - measured_value\n\n        # Proportional term\n        P = self.Kp * error\n\n        # Integral term (accumulated error)\n        self.integral += error * self.dt\n        I = self.Ki * self.integral\n\n        # Derivative term (rate of change)\n        derivative = (error - self.prev_error) / self.dt\n        D = self.Kd * derivative\n\n        # Total control output\n        output = P + I + D\n\n        # Update state\n        self.prev_error = error\n\n        return output\n\n# Example: Control joint to 90\xb0\ncontroller = PIDController(Kp=10.0, Ki=0.5, Kd=2.0, dt=0.01)\n\ncurrent_angle = 0.0  # Starting at 0\xb0\ntarget_angle = 90.0\n\nfor step in range(100):\n    # Compute control command\n    torque = controller.compute(target_angle, current_angle)\n\n    # Simulate robot response (simplified)\n    current_angle += torque * 0.01  # Simple integration\n\n    if step % 20 == 0:\n        print(f"Step {step}: Angle = {current_angle:.2f}\xb0, Torque = {torque:.2f}")\n'})}),"\n",(0,r.jsx)(e.h3,{id:"challenges-in-humanoid-robot-control",children:"Challenges in Humanoid Robot Control"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"High Dimensionality"}),": 25+ DOF requires coordinated control"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Underactuation"}),": Fewer actuators than DOF in some configurations (floating base)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Contact Dynamics"}),": Interaction with ground, objects (hybrid dynamics)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Balance"}),": Must maintain center of mass over support polygon"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Compliance"}),": Too stiff \u2192 fragile, too soft \u2192 imprecise"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Modern Approaches"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Model Predictive Control (MPC)"}),": Optimize over future horizon"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Whole-Body Control"}),": Coordinate all joints simultaneously"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Reinforcement Learning"}),": Learn control policies from data"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Impedance Control"}),": Control force vs. position tradeoff"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"bipedal-locomotion-walking-on-two-legs",children:"Bipedal Locomotion: Walking on Two Legs"}),"\n",(0,r.jsx)(e.p,{children:"Bipedal walking is one of the hardest problems in humanoid robotics."}),"\n",(0,r.jsx)(e.h3,{id:"the-balance-challenge",children:"The Balance Challenge"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Static Stability"}),": Center of Mass (CoM) stays within support polygon"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Slow, stable"}),"\n",(0,r.jsx)(e.li,{children:"Used by early robots (ASIMO)"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Dynamic Stability"}),": CoM can move outside support polygon during motion"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Fast, natural"}),"\n",(0,r.jsx)(e.li,{children:"Requires prediction and control (Boston Dynamics Atlas)"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Zero Moment Point (ZMP)"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Point on ground where net moment from contact forces is zero"}),"\n",(0,r.jsx)(e.li,{children:"If ZMP stays inside support polygon \u2192 stable walking"}),"\n",(0,r.jsx)(e.li,{children:"Widely used stability criterion"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"gait-phases",children:"Gait Phases"}),"\n",(0,r.jsx)(e.p,{children:"Humanoid walking involves cyclical phases:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Double Support"}),": Both feet on ground"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Single Support"}),": One foot on ground, other swinging"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Heel Strike"}),": Swinging foot contacts ground"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Toe Off"}),": Stance foot lifts off"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"walking-controllers",children:"Walking Controllers"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Traditional Approach"}),":"]}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"Plan footstep locations"}),"\n",(0,r.jsx)(e.li,{children:"Generate CoM trajectory (ZMP-based)"}),"\n",(0,r.jsx)(e.li,{children:"Inverse kinematics for joint trajectories"}),"\n",(0,r.jsx)(e.li,{children:"PID tracking control"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Modern Learning Approach"}),":"]}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"Train in simulation with RL"}),"\n",(0,r.jsx)(e.li,{children:"Learn robust policies that handle disturbances"}),"\n",(0,r.jsx)(e.li,{children:"Transfer to real robot (sim-to-real)"}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,r.jsx)(e.h3,{id:"1-degrees-of-freedom",children:"1. Degrees of Freedom"}),"\n",(0,r.jsx)(e.p,{children:"Count the DOF for:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"A simple gripper (2 fingers, 1 joint each)"}),"\n",(0,r.jsx)(e.li,{children:"A quadruped robot leg (4 legs, 3 joints per leg)"}),"\n",(0,r.jsx)(e.li,{children:"A humanoid torso (waist: 3 DOF, neck: 2 DOF)"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"2-forward-kinematics-calculation",children:"2. Forward Kinematics Calculation"}),"\n",(0,r.jsx)(e.p,{children:"Using the 2-link planar arm formula, compute end-effector position for:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"L\u2081 = 1.2m, L\u2082 = 0.9m"}),"\n",(0,r.jsx)(e.li,{children:"\u03b8\u2081 = 60\xb0, \u03b8\u2082 = -30\xb0"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"(Show your work step-by-step)"}),"\n",(0,r.jsx)(e.h3,{id:"3-inverse-kinematics-challenge",children:"3. Inverse Kinematics Challenge"}),"\n",(0,r.jsx)(e.p,{children:"Is the position (2.5m, 0.5m) reachable for a 2-link arm with L\u2081 = 1.0m, L\u2082 = 0.8m? Explain why or why not."}),"\n",(0,r.jsx)(e.h3,{id:"4-pid-tuning",children:"4. PID Tuning"}),"\n",(0,r.jsx)(e.p,{children:"Describe what happens in a PID controller if:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"K\u209a is too high"}),"\n",(0,r.jsx)(e.li,{children:"K\u1d62 is too high"}),"\n",(0,r.jsx)(e.li,{children:"K\u2090 is too high"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"5-code-challenge",children:"5. Code Challenge"}),"\n",(0,r.jsx)(e.p,{children:"Modify the PID controller code to:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["Add ",(0,r.jsx)(e.strong,{children:"integral windup protection"})," (limit integral term to \xb1100)"]}),"\n",(0,r.jsxs)(e.li,{children:["Add a ",(0,r.jsx)(e.code,{children:"reset()"})," method to clear integral and derivative terms"]}),"\n",(0,r.jsx)(e.li,{children:"Test with a step response and plot angle vs. time"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"6-walking-stability",children:"6. Walking Stability"}),"\n",(0,r.jsxs)(e.p,{children:["Research the ",(0,r.jsx)(e.strong,{children:"inverted pendulum model"})," used in humanoid walking. Explain in 3-4 sentences how it relates to balance control."]}),"\n",(0,r.jsx)(e.h3,{id:"7-design-exercise",children:"7. Design Exercise"}),"\n",(0,r.jsx)(e.p,{children:"You're designing a humanoid robot arm for assembly tasks. Decide:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"How many DOF? (justify)"}),"\n",(0,r.jsx)(e.li,{children:"Joint types and locations"}),"\n",(0,r.jsx)(e.li,{children:"Expected payload (weight it can carry)"}),"\n",(0,r.jsx)(e.li,{children:"Workspace (reachable volume)"}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,r.jsxs)(e.p,{children:["\u2705 Robots consist of ",(0,r.jsx)(e.strong,{children:"links"})," connected by ",(0,r.jsx)(e.strong,{children:"joints"}),", with DOF determining motion capability\n\u2705 ",(0,r.jsx)(e.strong,{children:"Forward kinematics"})," computes end-effector position from joint angles (easy)\n\u2705 ",(0,r.jsx)(e.strong,{children:"Inverse kinematics"})," computes joint angles for desired position (hard, multiple solutions)\n\u2705 ",(0,r.jsx)(e.strong,{children:"Dynamics"})," models forces and torques required for motion\n\u2705 ",(0,r.jsx)(e.strong,{children:"PID control"})," is fundamental for tracking desired trajectories\n\u2705 ",(0,r.jsx)(e.strong,{children:"Bipedal walking"})," requires sophisticated balance and coordination strategies\n\u2705 Modern humanoid control combines ",(0,r.jsx)(e.strong,{children:"model-based"})," and ",(0,r.jsx)(e.strong,{children:"learning-based"})," approaches"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Books"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.em,{children:"Introduction to Robotics: Mechanics and Control"})," by John J. Craig (classic kinematics/dynamics)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.em,{children:"Modern Robotics"})," by Lynch and Park (geometric approach)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.em,{children:"Humanoid Robots"})," by Kajita et al. (bipedal walking focus)"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Online Resources"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"MIT OpenCourseWare: Robotics (6.832)"}),"\n",(0,r.jsx)(e.li,{children:"Coursera: Robotics Specialization (UPenn)"}),"\n",(0,r.jsx)(e.li,{children:"ROS (Robot Operating System) tutorials"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Papers"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:'"Biped Walking Pattern Generation by using Preview Control of ZMP" (Kajita, 2003)'}),"\n",(0,r.jsx)(e.li,{children:'"Learning Agile and Dynamic Motor Skills for Legged Robots" (Hwangbo, 2019)'}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Videos"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Boston Dynamics Atlas parkour demonstrations"}),"\n",(0,r.jsx)(e.li,{children:"Honda ASIMO walking demos"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Previous"}),": ",(0,r.jsx)(e.a,{href:"/physical-ai-humanoid-robotics-book/docs/module-1/chapter-1-1",children:"\u2190 Chapter 1.1: AI Fundamentals"})," | ",(0,r.jsx)(e.strong,{children:"Next"}),": ",(0,r.jsx)(e.a,{href:"/physical-ai-humanoid-robotics-book/docs/module-1/chapter-1-3",children:"Chapter 1.3: Sensors and Actuators \u2192"})]}),"\n",(0,r.jsx)(e.p,{children:"Understanding kinematics and control is the foundation\u2014next, we'll explore the sensors and actuators that enable robots to perceive and act!"})]})}function h(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>t,x:()=>l});var s=i(6540);const r={},o=s.createContext(r);function t(n){const e=s.useContext(o);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:t(n.components),s.createElement(o.Provider,{value:e},n.children)}}}]);